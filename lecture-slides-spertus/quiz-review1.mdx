---
sidebar_position: 10
title: "Quiz 1 Review"
image: /img/lectures/web/l9.png
---

import RevealJS, { Slide } from '@site/src/components/RevealJS';
import Img from '@site/src/components/Img';
import PollSlide from '@site/src/components/PollSlide';
import QuizSlide from '@site/src/components/QuizSlide';

<style>
{`
  .reveal {
    font-size: 32px;
  }
`}
</style>

<RevealJS transition="slide">

<Slide>
<Img src="/img/lectures/web/qr1.gif"
  alt="User Friendly cartoon showing two people taking an exam at desks.
      Sound effects for Student 1: 'doink doink doink doink doing'
      Student 2: 'Hey...is that the sweet sound of a multiple-choice section I hear?'
      Student 1: 'Nope...essay question you have to answer in binary"
/>
</Slide>

<Slide>

## How much of the practice quiz did you do?

<PollSlide choices=
  {["None yet", "I've skimmed it", "A few problems", "Many problems", "All problems"]}
/>
</Slide>

<Slide>

## How hard do you think it is?

<PollSlide image="/img/lectures/poll-ev/pollev-smiles.png"
/>
<p>
Click below the faces if you haven't tried it yet.
</p>
</Slide>

<Slide>

## Cover Sheet
<p>
Write your roster name and your NUID neatly for OCR.
</p>

<Img src="/img/lectures/web/qr1-screenshot.png"
  alt="Screenshot of cover page, with spaces to write name and NUID"
/>

</Slide>

<Slide>

## Question 1: Write Once Run Anywhere
<QuizSlide
  question='Which statement best describes how Java achieves "write once, run anywhere"?'
  answers={[
    "Java source code is directly interpreted by the operating system",
    "Java source code is compiled to bytecode, which runs on the JVM available for each platform",
    "Java programs must be recompiled for each target operating system",
    "Java uses only ahead-of-time compilation to native machine code"
  ]}
/>
</Slide>

<Slide>

### Different CPUs and OSes Require Different Code

- CPUs have different instruction sets
- OS's have different APIs
- How do you run a program on *any* machine?

<aside class="notes">
**The fundamental problem:**
- Intel CPUs ≠ ARM CPUs (different instruction sets)
- Windows ≠ Linux ≠ macOS (different APIs)
- Traditional solution: platform-specific code or recompile → expensive, error-prone

**Java's solution:** Compile to intermediate representation → virtual machine runs it anywhere

**But:** How do you make that fast?

→ **Transition:** Enter bytecode...
</aside>

</Slide>

{/* ============================================ */}
{/* BYTECODE & JIT */}
{/* ============================================ */}

<Slide>
### Bytecode Provides Platform Independence
  <Img
    src="/img/lectures/web/l1-bytecode.webp"
    alt="Bytecode visualization"
  />

<aside class="notes">
**Bytecode = intermediate representation:**
- Java source → bytecode
- JVM on each platform executes bytecode
- You write once; JVM handles platform differences

**Both Python and Java use this approach** (in principle)

**Discussion:** "Is it really that easy?" Anyone compiled native Python extensions? That's when platform differences bite back.

→ **Transition:** But interpretation is slow...
</aside>

</Slide>
<Slide>
### Java compilation/execution

  <Img src="/img/lectures/ellen/l1-java-bytecode.svg"
    alt="Block diagram showing Java compilation-run process"
  />

</Slide>
<Slide>

### Compilation Enables Optimization

<div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5em', fontSize: '0.85em'}}>
  <div>
    <p style={{fontWeight: 'bold'}}>Interpreted</p>
    <ul style={{marginTop: '0.3em'}}>
      <li>Reads & executes line by line</li>
      <li>100s of instructions per statement</li>
      <li>Executes every branch, every time</li>
    </ul>
  </div>
  <div>
    <p style={{fontWeight: 'bold'}}>Native Compiled</p>
    <ul style={{marginTop: '0.3em'}}>
      <li>Already in machine code</li>
      <li>Direct CPU execution</li>
      <li>Dead code eliminated, functions inlined</li>
    </ul>
  </div>
</div>

<aside class="notes">
**Why interpretation is slower:**
- Interpreter: decode instruction → look up action → execute (100s of extra instructions)
- Native: CPU executes machine code directly

**Compiler optimizations interpreters can't do:**
- Dead code elimination, function inlining, loop optimizations

**Key difference:** Interpreter checks every branch every time. Compiler analyzes whole program and removes unnecessary work ahead of time.

→ **Transition:** Java's innovation: combine both approaches...
</aside>

</Slide>

<Slide>

### JIT Combines Interpretation with Native Compilation

<p >
  <strong>Just-In-Time (JIT)</strong> compilation
</p>
<p style={{marginTop: '1em'}}>
  Dynamically compiles bytecode <em>as it executes</em>
</p>
<p style={{marginTop: '1em'}}>
  The program that runs Java code: <strong>JVM</strong> (Java Virtual Machine)
</p>

<aside class="notes">
**JIT = Java's innovation:**
- JVM starts interpreting, monitors "hot" code (frequently run)
- Hot code → compiled to native on the fly
- Combines: bytecode portability + native speed

**Bonus:** JVM optimizes based on runtime behavior (ahead-of-time compilers can't!)

**Sidebar:** Other JVM languages: Kotlin (Android), Scala (big data), Clojure (functional), Groovy (scripting)—all benefit from JIT

→ **Transition:** Here's a concrete example of JIT optimization...
</aside>

</Slide>

<Slide>
### Question 1 Answer
<QuizSlide
  question='Which statement best describes how Java achieves "write once, run anywhere"?'
  answers={[
    "Java source code is directly interpreted by the operating system",
    "Java source code is compiled to bytecode, which runs on the JVM available for each platform",
    "Java programs must be recompiled for each target operating system",
    "Java uses only ahead-of-time compilation to native machine code"
  ]}
  correct={1}
/>
</Slide>

<Slide>

## Java Evolution

<Img src="/img/lectures/web/qr1-java-history.jpg"
    prompt="A whimsical editorial cartoon in warm sepia tones with color accents, showing Java as a vintage 1995 coffee maker that has been extensively modified over the decades.
The Original Machine (faded, ghostly outline in background):
A simple, elegant coffee maker labeled 'Java 1.0 — 1995' with clean lines and a prominent 'Write Once, Run Anywhere' badge. A small plaque reads: 'Simple. Object-Oriented. Familiar.'
The Modern Machine (center, detailed):
The same coffee maker, now barely recognizable under layers of modifications, additions, and duct-taped enhancements. Each addition is color-coded and labeled with its version:

Generics (Java 5, 2004): A complicated type-checking funnel bolted onto the input hopper, with labels like List<Coffee> and Map<String, Bean>. A ghost label reads 'Type Erasure Inside' with a knowing wink.
Lambda expressions (Java 8, 2014): Sleek arrow-shaped pipes (->) bypassing the original plumbing, with a 'Functional Interface Adapter' junction box.
Streams API (Java 8): A conveyor belt running parallel to the main mechanism, with .filter(), .map(), .collect() stations.
Records (Java 16, 2021): A compact, minimalist module snapped onto the side labeled 'Just the data, please.'
Sealed Classes (Java 17, 2021): A padlock and permit list attached to the class hierarchy chamber. Tags reading permits Espresso, Latte, Americano.
Pattern Matching (Java 21, 2023): A sophisticated sorting mechanism with instanceof patterns and switch arrows, looking almost alien compared to the original hardware.
Virtual Threads (Java 21): Hundreds of tiny lightweight threads (depicted as gossamer strands) replacing a few heavy ropes.
Characters:

An old-timer developer in a Sun Microsystems t-shirt gazes nostalgically at the ghostly original, coffee mug in hand.
A younger developer enthusiastically attaches yet another module labeled 'String Templates (Preview).'
James Gosling's portrait hangs on the wall, expression ambiguous—pride? bewilderment?
Speech bubbles:

Old-timer: 'I remember when we had to unbox Integers into ints'
Young developer: 'Wait until you see what's in Java 25!'
Bottom banner:
'Still backward compatible. Still brewing. Still Java?'"
alt="Cartoon of Java as a coffee maker evolving from 1995 to today. A simple original machine labeled 'Write Once, Run Anywhere' appears ghosted in the corner. The modern version is covered with bolted-on features: Generics funnel, Lambda arrow pipes, Streams conveyor belt, Records module, Sealed Classes padlock, and Pattern Matching tubes. An old developer in a Sun shirt reminisces while a young developer adds String Templates. Banner reads: 'Still backward compatible. Still brewing. Still Java?'"
/>

</Slide>

<Slide>

## How were new keywords be added to Java?

<p className="fragment">Why didn't adding keywords (<code>record</code>, <code>sealed</code>, etc.) break existing programs?</p>

<p className="fragment">They are <em>contextual keywords</em> (or "restricted identifiers").</p>

<p className="fragment">These words only have special meaning in specific syntactic contexts—so <code>int sealed = 42;</code> still compiles fine.</p>

</Slide>

<Slide>

## Question 2: Type Checking

Consider this code:

`Quantity q = new ExactQuantity(2.5, Unit.CUP);`

The compiler verifies that `ExactQuantity` is assignable to `Quantity`. This is an example of:
<QuizSlide
  answers={[
    "Dynamic typing - the type is checked when the program runs",
    "Static typing - the type is checked at compile time before the program runs",
    "Duck typing - any object with similar methods would work",
    "No type checking occurs"
  ]}
/>

</Slide>

<Slide>

### Why This is Legal

`Quantity q = new ExactQuantity(2.5, Unit.CUP);`

```mermaid
classDiagram
direction TB
    class Quantity {
        <<abstract>>
        -Unit unit
        #Quantity(Unit unit)
        +Unit getUnit()
    }

    class Unit {
              <<enumeration>>
    }
    class ExactQuantity {
        +DECIMAL_PRECISION: int$
        -double amount
        +ExactQuantity(double amount, Unit unit)
        +double getAmount()
    }

    Quantity <|-- ExactQuantity
    Quantity o--> Unit
```
Declaration uses abstract supertype.

Liskov Substitution Principle tells us assignment is legal.

</Slide>
<Slide>

### Kinds of Type Checking

* **Static Typing** (compile-time, Java)
  → Assignment is legal because `ExactQuantity extends Quantity`
* **Dynamic Typing** (run-time)
  * **Duck Typing** is a specific kind of dynamic typing (Python)

</Slide>

<Slide>

### Duck Typing vs Static Typing

<div className="fragment">

**Python (duck typing):** Type checked at runtime
```python
def make_sound(animal):
    animal.quack()  # No compile-time check—just tries it at runtime

make_sound(Duck())    # works because duck has quack()
make_sound(Person())  # works if Person has quack(), crashes otherwise
```

</div>
<div className="fragment">

**Java (static typing):** Type checked at compile time
```java
void makeSound(Quackable animal) {
    animal.quack();  // Compiler verifies animal implements Quackable
}
```

</div>

<p className="fragment">"If it walks like a duck and quacks like a duck, it's a duck."</p>

</Slide>

<Slide>
### Duck Typing (meme)

<Img src="/img/lectures/web/qr1-duck-typing.jpg"
    alt="Meme captioned 'duck typing' in which a person is connecting a plug to a pig's snout"/>
</Slide>

<Slide>

### Question 2 Answer

Consider this code:

`Quantity q = new ExactQuantity(2.5, Unit.CUP);`

The compiler verifies that `ExactQuantity` is assignable to `Quantity`. This is an example of:
<QuizSlide
  answers={[
    "Dynamic typing - the type is checked when the program runs",
    "Static typing - the type is checked at compile time before the program runs",
    "Duck typing - any object with similar methods would work",
    "No type checking occurs"
  ]}
  correct={1}
/>

</Slide>
<Slide>
## Question 3: Liskov Substitution Principle

In CookYourBooks, `ExactQuantity`, `FractionalQuantity`, and `RangeQuantity` all extend `Quantity`.

According to the Liskov Substitution Principle:

<QuizSlide
  answers={[
    "Each subclass can implement toDecimal() to return any value it wants",
    "Each subclass must be usable anywhere a Quantity is expected without breaking the program",
    "Subclasses must have identical implementations of all methods",
    "Only ExactQuantity can be used where Quantity is expected"
  ]}
/>

</Slide>

<Slide>

### UML
In CookYourBooks, `ExactQuantity`, `FractionalQuantity`, and `RangeQuantity` all extend `Quantity`.

```mermaid
classDiagram
    class Quantity {
        <<abstract>>
        double toDecimal()*
    }

    class ExactQuantity {
        double toDecimal()
    }

    class FractionalQuantity {
        double toDecimal()
    }

    class RangeQuantity {
        double toDecimal()
    }

    Quantity <|-- ExactQuantity
    Quantity <|-- FractionalQuantity
    Quantity <|-- RangeQuantity
    ```
<p className="fragment">
What does the Liskov Substitution Principle tell us?
</p>
 <p className="fragment" style={{marginTop: '0em'}}>
An instance of the subtype can be passed where an instance of the supertype is expected.
</p>
</Slide>

<Slide>
### Superman is Above the Submarine

<Img src="/img/lectures/web/qr1-super-sub.jpg"
    alt="Cartoon image showing Superman in the sky and a submarine under water"
/>

</Slide>

<Slide>

### Question 3 Answer

Consider this code:

`Quantity q = new ExactQuantity(2.5, Unit.CUP);`

The compiler verifies that `ExactQuantity` is assignable to `Quantity`. <br/>This is an example of:
<QuizSlide
  answers={[
    "Dynamic typing - the type is checked when the program runs",
    "Static typing - the type is checked at compile time before the program runs",
    "Duck typing - any object with similar methods would work",
    "No type checking occurs"
  ]}
  correct={1}
/>

</Slide>

<Slide>

## Question 4: Abstract Classes

Why is `Quantity` declared as an `abstract class` rather than a regular class?

<QuizSlide
  answers={[
    "Abstract classes use less memory",
    "It has abstract methods like toDecimal() that subclasses must implement, and it should not be instantiated directly",
    "Java requires all parent classes to be abstract",
    "It makes the class immutable"
  ]}
/>

</Slide>

<Slide>
### A Closer Look at Quantity

```mermaid
classDiagram
    class Quantity {
        <<abstract>>
        -Unit unit
        #Quantity(Unit unit)
        +Unit getUnit()
        +double toDecimal()*
        +String toString()
    }

    class ExactQuantity {
        double toDecimal()
    }

    class FractionalQuantity {
        double toDecimal()
    }

    class RangeQuantity {
        double toDecimal()
    }

    Quantity <|-- ExactQuantity
    Quantity <|-- FractionalQuantity
    Quantity <|-- RangeQuantity
    ```

```
public abstract class Quantity {
  public Quantity(Unit unit) { ... }

  public abstract double toDecimal();

  @Override public toString() { ... }
}
```
</Slide>

<Slide>

### Abstract vs Concrete Classes

<table style={{ fontSize: '0.85em' }}>
  <thead>
    <tr>
      <th></th>
      <th style={{ textAlign: 'center' }}>Abstract Class</th>
      <th style={{ textAlign: 'center' }}>Concrete Class</th>
    </tr>
  </thead>
  <tbody>
    <tr className="fragment">
      <td>Can contain concrete methods</td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
    </tr>
    <tr className="fragment">
      <td>Can contain abstract methods</td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
      <td><div style={{ textAlign: 'center' }}>✗</div></td>
    </tr>
    <tr className="fragment">
      <td>Can be instantiated</td>
      <td><div style={{ textAlign: 'center' }}>✗</div></td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
    </tr>
    <tr className="fragment">
      <td>Can be extended</td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
      <td><div style={{ textAlign: 'center' }}>✓</div></td>
    </tr>
  </tbody>
</table>

</Slide>

<Slide>
### Question 4 Answer

Why is `Quantity` declared as an `abstract class` rather than a regular class?

<QuizSlide
  correct={1}
  answers={[
    "Abstract classes use less memory",
    "It has abstract methods like toDecimal() that subclasses must implement, and it should not be instantiated directly",
    "Java requires all parent classes to be abstract",
    "It makes the class immutable"
  ]}
/>

</Slide>

<Slide>
### Abstract Classes (meme)

<Img src="/img/lectures/web/qr1-abstract-class-meme.webp"
    alt="A meme from Family Guy showing Noah on the ark looking confused at two mixed-up animal pairs. A penguin stands with an elephant labeled 'Abstract Classes' while another elephant stands with a penguin labeled 'Interfaces'. A third label reads 'Inheritance'. Noah gestures in confusion with the caption 'What the hell is this?'"
/>

</Slide>

<Slide>

## Question 5: Exceptions

What distinguishes checked exceptions (e.g., `IOException`) from unchecked exceptions (e.g., `IllegalArgumentException`)?

<QuizSlide
  answers={[
    "Checked exceptions are faster to throw",
    "Checked exceptions must be declared in the method signature or caught; unchecked exceptions do not",
    "Unchecked exceptions cannot be caught",
    "Checked exceptions extend RuntimeException"
  ]}
/>

</Slide>

<Slide>

### Checked and Unchecked Exceptions

  <Img
    src="/img/lectures/web/l2-exceptions.webp"
    alt="Airport customs: green channel for unchecked exceptions, red channel for checked exceptions"
    prompt="Revised: 'The Arrivals Hall' (Airport Declaration Channels)
A cheerful airport arrivals hall rendered in the style of a friendly airport signage system—think IKEA-meets-international-terminal wayfinding design. The scene shows the familiar customs area after landing, with two clearly marked channels. The green channel ('Nothing to Declare' / Unchecked Exceptions) shows travelers like NullPointerException and IllegalArgumentException walking straight through without stopping—no paperwork, no inspection, just a quick passage into the main terminal. A small sign notes: 'Travelers choosing this channel accept responsibility for any undeclared items.' The red channel ('Goods to Declare' / Checked Exceptions) shows travelers like IOException and SQLException stopping at a customs desk, filling out declaration forms (the throws clause), having their bags inspected (the try-catch block), and getting their forms stamped before proceeding. The process is slower but orderly. Friendly customs officers (the compiler) check that all declarations match what's actually being carried.
This visualization keeps the 'two paths with different requirements' structure while using a universally relatable, low-stakes scenario that most travelers have experienced. The green/red channel system is internationally recognized and immediately intuitive: some things require declaration, others don't. The metaphor maps cleanly: checked exceptions are like goods that must be declared—you can't just walk through pretending you don't have them. Unchecked exceptions are like personal items—no declaration required, but if something goes wrong (you actually did have something to declare), that's on you. Details include: declaration forms with fields for 'Exception Type' and 'Handling Strategy,' a duty-free shop in the background labeled 'Standard Exceptions' (the ones you don't need to create yourself), and arrival screens showing 'Flight from MethodCall' and 'Destination: CallerLand.' A small Error like OutOfMemoryError appears as an emergency exit—bypassing customs entirely because the whole terminal is being evacuated. The friendly airport aesthetic makes exception handling feel routine rather than adversarial. Tagline: 'Some exceptions require declaration. Know which channel you're in.'"
  />

</Slide>

<Slide>

### Java's Exception Hierarchy Distinguishes Error Types

<p style={{fontSize: '1.1em'}}>
  All exceptions extend <code>Throwable</code>
</p>

```mermaid
classDiagram
    class Throwable {
    }
    class Exception {
    }
    class RuntimeException {
    }
    class Error {
    }
    Throwable <|-- Exception
    Throwable <|-- Error
    Exception <|-- RuntimeException
    Exception <|-- IOException
    RuntimeException <|-- NullPointerException
    RuntimeException <|-- IllegalArgumentException
    RuntimeException <|-- IndexOutOfBoundsException
```
Subclasses of `Error` and `RuntimException` are unchecked.

</Slide>

<Slide>

### Parameter Validation

* Validate constructor and method parameters as early as possible
* Throw `IllegalArgumentException`
* Document requirements and exceptions in Javadoc

```java
  /**
   * Creates an ingredient with the given name, preparation, and notes.
   *
   * @param name the ingredient name (must not be null or blank)
   * @param preparation the preparation instructions (may be null)
   * @param notes additional notes (may be null)
   * @throws IllegalArgumentException if name is blank (empty or whitespace-only)
   */
  protected Ingredient(@NonNull String name, @Nullable String preparation, @Nullable String notes) {
    if (name.isBlank()) {
      throw new IllegalArgumentException("Name must not be blank.");
    }
    ...
  }
```

</Slide>

<Slide>

### Two Ways to Handle Checked Exceptions

<div style={{ display: 'flex', gap: '2em', fontSize: '0.7em' }}>

<div className="fragment">

**Option 1: Catch it**
```java
public void processFile(String path) {
    try {
        String data = readFile(path);
        // use data
    } catch (IOException e) {
        System.err.println("Could not read file: "
            + e.getMessage());
    }
}
```

Handle the problem here.

</div>

<div className="fragment">

**Option 2: Propagate it**
```java
public void processFile(String path) throws IOException {
    String data = readFile(path);
    // use data
}
```

Let the caller handle it.

</div>

</div>

</Slide>

<Slide>

<Img src="/img/lectures/web/qr1-babysitter-exception-handling.jpg"
  prompt="A warm, storybook illustration style showing two side-by-side scenes of babysitters dealing with a crying baby at night.
Left panel — 'The Good Babysitter (Catch It)':
A calm, competent babysitter in a cozy nursery, successfully soothing a baby who was just crying. The babysitter rocks the baby gently, perhaps with a lullaby note floating in the air. A teddy bear and warm nightlight set a peaceful scene. The baby is settling down, tears drying.
Label above: catch (CryingBabyException e)
Large code snippet on a sticky note on the wall:
try {    baby.putToBed();} catch (CryingBabyException e) {    baby.soothe();    baby.singLullaby();}

Caption below: 'Handles the problem. Parents sleep peacefully.'
A thought bubble from the babysitter: 'I got this.'
Right panel — 'The Bad Babysitter (Declare It)':
A frazzled babysitter standing at the parents' bedroom door at 2 AM, holding a screaming baby at arm's length, passing the crying child to exhausted, disheveled parents in pajamas. The parents look annoyed and sleepy. The nursery behind is in disarray.
Label above: throws CryingBabyException
Lage code snippet on a note falling to the floor: public void watchBaby() throws CryingBabyException {    baby.putToBed(); // not my problem!}
Caption below: 'Propagates the problem. Parents deal with it.'
A thought bubble from the babysitter: 'Above my pay grade.'
Bottom banner:
'Checked exceptions: Handle them or declare them. Someone has to deal with it eventually.'
Visual consistency:
Same baby, same crib, same house — only the babysitter's response differs. Clock on wall shows late night in both panels. Color palette shifts from warm greens and yellows (left/good) to stressed oranges and reds (right/bad)."
  alt="Two-panel storybook illustration titled 'Babysitter Exception Handling'. Left panel labeled 'The Good Babysitter (Catch It)' shows a calm babysitter in a rocking chair holding a content baby in a peaceful nursery at night. A code snippet reads 'try { baby.putToBed(); } catch (CryingBabyException e) { baby.soothe(); baby.singLullaby(); }'. Speech bubble says 'I got this.' Caption: 'Handles the problem. Parents sleep peacefully.' Right panel labeled 'The Bad Babysitter (Declare It)' shows a frazzled babysitter handing a crying baby to exhausted parents in pajamas. Speech bubble says 'Above my pay grade.' Caption: 'Propagates the problem. Parents deal with it.' Bottom banner reads 'Checked exceptions: Handle them or declare them. Someone has to deal with it eventually.'"
/>
</Slide>

<Slide>

### Question 5 Answer

What distinguishes checked exceptions (e.g., `IOException`) from unchecked exceptions (e.g., `IllegalArgumentException`)?

<QuizSlide
  correct={1}
  answers={[
    "Checked exceptions are faster to throw",
    "Checked exceptions must be declared in the method signature or caught; unchecked exceptions do not",
    "Unchecked exceptions cannot be caught",
    "Checked exceptions extend RuntimeException"
  ]}
/>

</Slide>

</RevealJS>