---
sidebar_position: 4
title: Specifications and Common Contracts
image: /img/lectures/web/l4.png
---

import RevealJS, { Slide } from '@site/src/components/RevealJS';
import Img from '@site/src/components/Img';
import PollSlide from '@site/src/components/PollSlide';

<RevealJS transition="slide">

{/* ============================================ */}
{/* COVER IMAGE */}
{/* ============================================ */}

<Slide>
  <Img
    src="/img/lectures/web/l4.png"
    prompt="Concept: 'The Vending Machine Contract' (Program Design & Implementation)Tagline: 'Same Promise. Many Machines.'Subtitle: 'Specifications: The Boundary of Trust.'
A pixel art style educational illustration showing the concept of interface contracts and implementations. The scene shows three vending machines side by side, each with the same interface but different internal mechanisms, plus a rejected fourth machine demonstrating contract violation.
Header banner:
'CS 3100: Program Design & Implementation 2' with subtitle 'The Vending Machine Contract'
Machine 1 ‚Äî 'Machine 1 (Gravity)':
A vending machine with a simple gravity-based mechanism visible through a cutaway view. Metal ramps and chutes guide products down using gravity and springs. The display shows three items: 'A1: Chips ($1.00)', 'B2: Soda ($1.50)', 'C3: Candy ($0.75)'. A customer stands in front, with a speech bubble saying 'Simple promise. I trust it.' A chip bag slides down the ramp toward the dispensing slot.
Machine 2 ‚Äî 'Machine 2 (Pneumatic)':
A vending machine with an elaborate pneumatic tube system visible through a cutaway view. Pipes, pressure gauges, valves, and steam elements create a complex but functional delivery system. Same display showing identical items: 'A1: Chips ($1.00)', 'B2: Soda ($1.50)', 'C3: Candy ($0.75)'. A customer presses the B2 button, and a soda can travels through the pneumatic tubes toward the output.
Machine 3 ‚Äî 'Machine 3 (Hamsters)':
A vending machine with an absurd hamster-powered mechanism visible through a cutaway view. Hamsters run on wheels, operate tiny conveyor belts, and push products through an elaborate Rube Goldberg-style system with gears and pulleys. Same display showing identical items: 'A1: Chips ($1.00)', 'B2: Soda ($1.50)', 'C3: Candy ($0.75)'. A customer waits as hamsters work to deliver a candy bar through the ridiculous but functional system.
Below the three machines:
A label reads: 'Generality: Multiple implementations satisfy the same spec.'
Rejected machine scene (bottom right corner):
A broken, malfunctioning vending machine lies cracked and tilted in a trash heap. Its display shows 'A1: Chips ($1.00)' but instead of chips, a boot sits in the dispensing tray. A large red X marks the machine. Callout labels read: 'Failed Contract! Promised Chips, Dispensed Boot.' and 'Rejected Machine (Violation)'. Additional label: 'Restrictiveness: Violations Rejected.'
Bottom banner:
'Same Promise. Many Machines.' with subtitle 'Specifications: The Boundary of Trust.'
Visual style:
Retro pixel art with a cohesive color palette of teals, blues, and warm accents. Clear cutaway views showing internal mechanisms. Consistent vending machine frames with identical user interfaces despite wildly different implementations."
  alt='A pixel art illustration titled "The Vending Machine Contract" showing three vending machines with identical interfaces (Chips $1.00, Soda $1.50, Candy $0.75) but different internal mechanisms: one uses gravity and ramps, one uses pneumatic tubes with steam gauges, and one uses hamsters running on wheels and conveyor belts. All three successfully deliver the correct products. In the corner, a rejected fourth machine lies broken in a trash heap‚Äîit promised chips but dispensed a boot, violating the contract. The caption reads "Same Promise. Many Machines." illustrating how multiple implementations can satisfy the same specification, but violations are rejected.'
/>

<aside className="notes">
**Lecture overview:**
- **Total time:** ~50 minutes
- **Prerequisites:** Students understand Java basics, inheritance, interfaces from L1-L3
- **Connects to:** Assignment 1 (writing well-specified methods), Lab 3 (code readability)

**Structure:**
- Why specifications matter (psychology + modularity) (~10 min)
- Three criteria for good specs: restrictiveness, generality, clarity (~15 min)
- Type annotations for machine-readable specs (~8 min)
- Common Object contracts: toString, equals, hashCode, compareTo (~17 min)

**Key theme:** Specifications are contracts between implementers and clients‚Äîthey enable large-scale software development by letting developers reason about code without reading implementations.

‚Üí **Transition:** Let's start with the learning objectives...
</aside>

</Slide>

{/* ============================================ */}
{/* TITLE SLIDE */}
{/* ============================================ */}

<Slide>

# CS 3100: Program Design and Implementation II

## Lecture 4: Specifications and Common Contracts

<p style={{marginTop: '2em', fontSize: '0.8em', color: '#666'}}>
  ¬©2025 Jonathan Bell, CC-BY-SA
</p>

<aside className="notes">
**Context from L2-L3:**
- Students learned inheritance, polymorphism, Java syntax details
- This lecture focuses on *how to document* what methods do
- Critical for working in teams and on larger codebases

**Key theme:** Good specifications are the glue that holds large software systems together.

‚Üí **Transition:** Here's what you'll be able to do after today...
</aside>

</Slide>

{/* ============================================ */}
{/* LEARNING OBJECTIVES */}
{/* ============================================ */}

<Slide>

## Learning Objectives

<p style={{fontSize: '0.85em', textAlign: 'left'}}>
After this lecture, you will be able to:
</p>

<ol style={{fontSize: '0.75em', textAlign: 'left'}}>
  <li>Describe the role of method specifications in achieving program modularity and improving readability</li>
  <li>Evaluate the efficacy of a given specification using the terminology of restrictiveness, generality, and clarity</li>
  <li>Utilize type annotations to express invariants such as non-nullness</li>
  <li>Define the role of methods common to all Objects in Java (toString, equals, hashCode, compareTo)</li>
</ol>

<aside className="notes">
**Time allocation:**
- Objective 1: Why specs matter‚Äîpsychology and modularity (~10 min)
- Objective 2: The three criteria‚Äîrestrictiveness, generality, clarity (~15 min)
- Objective 3: Type annotations‚Äî@NonNull, @NullMarked (~8 min)
- Objective 4: Object contracts‚Äîfour essential methods (~17 min)

**Why this matters:** Students will write Javadoc for A1 methods. They need to understand what makes a spec good vs. merely present. They'll also override equals/hashCode for domain classes.

**AI foreshadowing:** Later in the course, students will use AI assistants. The spec skills they learn today directly apply‚Äîambiguous prompts yield unpredictable results.

‚Üí **Transition:** Let's start with a surprising fact about human memory...
</aside>

</Slide>

{/* ============================================ */}
{/* ARC 1: WHY SPECIFICATIONS MATTER */}
{/* ============================================ */}

<Slide>

## Humans Can Only Hold 7¬±2 Items in Working Memory

<p style={{fontSize: '0.85em', marginTop: '0.5em'}}>
  Which is easier to remember?
</p>

<ul style={{fontSize: '0.8em'}}>
  <li><strong>Random order:</strong> 50, 30, 60, 20, 80, 10, 40, 70</li>
  <li><strong>Pattern:</strong> 10, 20, 30, 40, 50, 60, 70, 80</li>
</ul>

<aside className="notes">
**Miller's Law (1956):**
- George Miller's famous paper: "The Magical Number Seven, Plus or Minus Two"
- We can only hold ~7 items in short-term/working memory at once
- BUT: items can be "chunks" of variable size

**The example:**
- Both lists contain the same 8 numbers
- Random order: 8 separate items (exceeds capacity)
- Pattern: 1 chunk ("multiples of 10")
- Same information, dramatically different cognitive load

**Why this matters for programming:**
- We can't hold entire programs in our heads
- We need to "chunk" code into understandable pieces
- Specifications are how we create mental chunks

‚Üí **Transition:** Let's dig deeper into what "chunking" means...
</aside>

</Slide>

<Slide>

## Chunking Lets Us Manage More Than 7 Items

<p style={{fontSize: '0.9em'}}>
  <strong>Chunking</strong> = organizing information into meaningful units
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li>"FBI" is 1 chunk, not 3 letters</li>
  <li>"555-1234" is 2 chunks, not 7 digits</li>
  <li>A chess master sees "castled king position" not 5 pieces</li>
</ul>

<p style={{fontSize: '0.9em', marginTop: '1em', color: '#9370DB'}}>
  Expert programmers chunk code the same way:
</p>

<ul style={{fontSize: '0.85em'}}>
  <li>"Binary search" ‚Üí one chunk (not 15 lines)</li>
  <li>"HashMap lookup" ‚Üí one chunk (not the internal algorithm)</li>
</ul>

<aside className="notes">
**The psychology:**
- Experts don't have bigger working memory
- They have better chunks
- A chess grandmaster and novice have same 7¬±2 limit
- But grandmaster's chunks are entire board positions

**For programmers:**
- Novice: sees individual statements, loops, conditions
- Expert: sees "sorting," "searching," "validation"
- Specs let everyone think at the expert level

**The key insight:**
- Chunking requires LABELS for the chunks
- In code, the label is the specification
- Without a spec, you can't chunk the method‚Äîyou have to hold the whole thing

‚Üí **Transition:** So how do specifications enable chunking?
</aside>

</Slide>

<Slide>

## Specifications Enable Mental Chunking for Code

<p style={{fontSize: '0.9em'}}>
  When reading a program, we want to understand method behavior <strong>without</strong> reading the implementation.
</p>

<div style={{display: 'flex', gap: '1em', marginTop: '1em'}}>
<div style={{flex: 1}}>

**Without spec:** ü§Ø

```java
public int mystery(int[] arr) {
    int result = 0;
    for (int i = 0; i < arr.length; i++) {
        result += arr[i];
    }
    return result;
}
```

<p style={{fontSize: '0.7em', color: '#888'}}>Must read every line to understand</p>

</div>
<div style={{flex: 1}}>

**With spec:** üòå

```java
/**
 * Calculates the sum of the elements.
 * @return the sum of the elements, or 0 if arr is empty
 * @throws NullPointerException if arr is null
 */
public int sum(int[] arr) {
    // ... implementation ...
}
```

<p style={{fontSize: '0.7em', color: '#888'}}>Spec tells you what it does</p>

</div>
</div>

<aside className="notes">
**The chunking connection:**
- Left side: must hold the entire implementation in memory
- Right side: one chunk‚Äî"sums the array"
- The spec lets you skip the implementation details

**Real-world scale:**
- Methods call other methods, which call other methods...
- Without specs, understanding one method requires understanding all its dependencies
- With specs, each method is a self-contained chunk

**Good naming helps too:**
- "mystery" vs "sum"‚Äînames are part of the specification
- But names alone aren't enough for complex behavior

‚Üí **Transition:** Let's see the real-world impact of this...
</aside>

</Slide>

<Slide>

## You Spend 10x More Time Reading Code Than Writing It

<p style={{fontSize: '0.9em'}}>
  You spend <strong>10x more time reading code</strong> than writing it.
</p>

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Consider understanding this call:
</p>

```java
int index = collection.binarySearch(target);
```

<div style={{display: 'flex', gap: '1em', marginTop: '0.5em', fontSize: '0.8em'}}>
<div style={{flex: 1}}>

**Without spec:**
- Open the source file
- Read 30 lines of implementation
- Understand loop invariants
- Figure out edge cases
- **Time: 5-10 minutes**

</div>
<div style={{flex: 1}}>

**With spec:**
- Read 3-line Javadoc
- Understand behavior, errors, edge cases
- **Time: 30 seconds**

</div>
</div>

<aside className="notes">
**The math:**
- Average codebase: thousands of methods
- Each method calls several others
- Without specs: O(n¬≤) effort to understand
- With specs: O(n) effort

**Industry impact:**
- Onboarding new developers
- Code review speed
- Bug investigation time
- All dramatically improved by good specs

**The investment:**
- Yes, writing specs takes time
- But it's amortized across every future reader
- Write once, read hundreds of times

‚Üí **Transition:** So specs are valuable. But what makes a spec *good*?
</aside>

</Slide>

<Slide>

## A Good Specification Lets You Predict Behavior

<p style={{fontSize: '0.95em'}}>
  The goal: a developer can understand what a method does <strong>without reading its code</strong>.
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li>Any implementation that <strong>satisfies</strong> the spec is correct</li>
  <li>Any implementation that <strong>violates</strong> the spec is incorrect</li>
  <li>The spec should be <strong>easier to understand</strong> than the implementation</li>
</ul>

<p style={{fontSize: '0.9em', marginTop: '1.5em', color: '#9370DB'}}>
  But how do we evaluate whether a specification is good?
</p>

<aside className="notes">
**Three requirements of a good spec:**
1. Correct implementations satisfy it (not too restrictive)
2. Incorrect implementations violate it (sufficiently restrictive)
3. It's actually easier to understand than the code

**The balance:**
- Too vague: doesn't rule out incorrect implementations
- Too detailed: might as well read the code
- Just right: captures essential behavior, omits implementation details

**Source material:**
- This framework comes from Liskov & Guttag, "Program Development in Java"
- Chapter 9.2 is excellent reference for students who want more depth

‚Üí **Transition:** Let's look at three specific criteria for evaluating specifications...
</aside>

</Slide>

{/* ============================================ */}
{/* ARC 2: THREE CRITERIA FOR GOOD SPECIFICATIONS */}
{/* ============================================ */}

<Slide>

## Good Specifications Balance Three Criteria

<Img
    src="/img/lectures/web/l4-three-criteria.png"
    prompt="Concept: 'The Goldilocks Specification Lab' (Finding the Just-Right Balance)

A whimsical-yet-technical laboratory scene rendered in a storybook-meets-engineering style, showing three experimental stations where specifications are being tested.

STATION 1 - 'TOO RESTRICTIVE' (Left):
A specification document trapped in a tiny, rigid metal cage with bars too close together. Multiple implementations try to enter‚Äîsome clearly buggy (marked with X), but ALSO several perfectly good implementations (marked with ‚úì) that can't fit through the narrow bars. A frustrated 'Binary Search' algorithm waves from outside: 'But I'm correct! The spec just demands linear search!' The cage label reads: 'Operational Spec: Must examine each element in order.' A thermometer-style gauge shows 'Flexibility: FROZEN'. Red warning lights flash. Annotation: 'Rejects valid implementations‚Äîtoo picky about HOW, not just WHAT.'

STATION 2 - 'TOO GENERAL' (Center):
A specification document as a wide-open barn door with no filter at all. A parade of implementations walks through‚Äîsome with ‚úì checkmarks (good), but also clearly buggy ones with skull icons: 'Returns 0 if item not found!' 'Crashes randomly!' 'Deletes your files!' The bouncer (labeled 'Spec') shrugs helplessly: 'The spec just says return an index, not what to do if item isn't found!' A gauge shows 'Flexibility: ANYTHING GOES'. Yellow caution tape everywhere. Annotation: 'Accepts buggy implementations‚Äîundefined behavior lurks.'

STATION 3 - 'UNCLEAR' (Right):
A specification document written in tiny, smudged text with contradictory arrows and question marks. Three developers stand around it, each with a different thought bubble showing completely different interpretations: Dev A thinks 'Returns first index', Dev B thinks 'Returns any index', Dev C thinks 'Returns -1 if not found'. They're all building different implementations, all thinking they're correct. A 'Confidence Meter' shows all three developers at 100% confidence despite complete disagreement. Annotation: 'Readers THINK they understand‚Äîthe most dangerous failure.'

CENTER - 'JUST RIGHT' (Highlighted, Glowing):
A perfectly balanced specification shown as a well-designed filter/gate system. The gate is sized exactly right: buggy implementations (with X marks) bounce off, while ALL valid implementations (linear search, binary search, parallel search‚Äîall with ‚úì) pass through smoothly. The spec text is clear and readable: 'Returns AN index containing target, or throws exception if not found.' Developers reading it all have the same thought bubble. A 'Specification Quality' gauge shows three green bars: Restrictive ‚úì, General ‚úì, Clear ‚úì.

BOTTOM SUMMARY:
Three columns showing the balance:
- Restrictiveness: 'Rules out BAD implementations' (bouncer icon)
- Generality: 'Permits GOOD implementations' (welcome mat icon)
- Clarity: 'Everyone understands the SAME thing' (lightbulb icon)
Central message: 'All three must be balanced‚Äîoptimize for any one alone and the spec fails.'

Style: Warm fairy-tale laboratory aesthetic with technical precision‚Äîthink Wes Anderson directing a computer science documentary. Color palette: warm ambers for 'too restrictive', chaotic rainbow for 'too general', foggy grays for 'unclear', and a warm golden glow for 'just right'. Should feel like a memorable fable that teaches a real engineering principle."

    alt='A whimsical laboratory illustration titled "The Goldilocks Specification Lab." Three stations demonstrate specification failures: "Too Restrictive" shows a cage rejecting valid code like Binary Search; "Too General" depicts a barn door admitting buggy implementations; and "Unclear" features confused developers interpreting smudged text differently. In the glowing center, a "Just Right" machine perfectly filters code, allowing all valid implementations (linear, binary, parallel) to pass while rejecting bugs. A summary panel emphasizes balancing restrictiveness, generality, and clarity to create effective software specifications.' />


<aside className="notes">
**The three-legged stool metaphor:**
- All three legs must be the right length
- If any one is wrong, the stool (and your spec) falls over

**Quick definitions:**
- **Restrictiveness:** Does the spec rule out BAD implementations?
- **Generality:** Does the spec allow GOOD implementations?
- **Clarity:** Can readers UNDERSTAND the spec correctly?

**The tension:**
- More restrictive often means less general (and vice versa)
- More detailed might help clarity OR hurt it (too long to read)
- Good specs balance all three

‚Üí **Transition:** Let's look at each criterion with concrete examples, starting with restrictiveness...
</aside>

</Slide>

<Slide>

## Restrictive Specs Rule Out Bad Implementations

<p style={{fontSize: '0.9em'}}>
  A spec is <strong>restrictive</strong> if it rules out implementations that clients would find unacceptable.
</p>

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Think of it as: <em>"What BAD behaviors does this spec prohibit?"</em>
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li>Does it specify what happens for ALL inputs?</li>
  <li>Does it prohibit surprising or dangerous behavior?</li>
  <li>Could a malicious implementer satisfy it while being useless?</li>
</ul>

<aside className="notes">
**The key question:**
- For every possible input, is the behavior defined?
- If not, an implementer could do ANYTHING for undefined inputs
- "Undefined behavior" in specs = bugs waiting to happen

**Examples of restrictiveness failures:**
- Not specifying null handling
- Not specifying ordering guarantees
- Not specifying thread safety
- Not specifying what exceptions can be thrown

**The adversarial test:**
- Imagine an "evil" implementer trying to satisfy the spec while being unhelpful
- If they can do something bad that satisfies the spec, it's not restrictive enough

‚Üí **Transition:** Let's see a concrete example of an under-specified method...
</aside>

</Slide>

<Slide>

## Under-Specified Behavior Allows Bugs to Hide

<Img
    src="/img/lectures/web/l4-underspecified.webp"
    alt="Concept: 'The Undefined Behavior Roulette Wheel' (What Happens When Specs Have Gaps)

A dramatic casino/game-show style illustration showing the danger of under-specified behavior.

CENTER - THE ROULETTE WHEEL:
A large spinning wheel divided into wedges, each showing a different possible outcome for 'sum(null)'. The wheel is labeled 'What happens when arr is null?' and is being spun by an ominous figure labeled 'Undefined Behavior'. The wedges include:
- 'Throw NullPointerException' (reasonable)
- 'Return 0' (maybe intended?)
- 'Return -1' (huh?)
- 'Crash the JVM' (disaster)
- 'Hang forever' (worse)
- 'Corrupt data silently' (technically allowed!)
- 'Work fine... sometimes' (worst‚Äîintermittent bugs)
A small annotation: 'All of these satisfy the spec! The spec is silent on null.'

LEFT SIDE - THE SPEC:
A document showing:
```
/** Returns the sum of elements.
 * @param arr the array
 * @return the sum
 */
```
With a magnifying glass highlighting the ABSENCE of any null handling. A detective character points at the gap: 'No mention of null = UNDEFINED = anything goes!'

RIGHT SIDE - THE CONSEQUENCES:
Three developers at different companies building on this library:
- Dev A (Library v1.0) implements: throws NPE
- Dev B (Library v2.0) implements: returns 0
- Dev C (Fork) implements: crashes
All three say 'My implementation matches the spec!' Meanwhile, OTHER DEVELOPERS who depend on this library are shown at the bottom, frustrated‚Äîtheir code breaks unpredictably when switching library versions. Speech bubble: 'I upgraded the library and now my tests fail randomly!'

BOTTOM - THE FIX:
A 'well-specified' version with '@throws NullPointerException if arr is null' highlighted in green. The roulette wheel is replaced with a single, predictable path. Caption: 'Silence in a spec = undefined behavior. Define ALL edge cases so developers using your API can rely on consistent behavior.'

Style: Dramatic game-show/casino aesthetic with spotlights, danger colors (reds, blacks), and the tension of gambling. Should convey that leaving behavior undefined is literally gambling with API consumers' ability to write reliable code."
  />
<aside className="notes">
**The problem:**
- Spec says nothing about null input
- Behavior is "undefined" for null
- Implementation could: throw exception, return 0, crash the JVM, launch missiles...
- All would technically satisfy this spec!

**Why this matters:**
- Callers can't predict what happens with null
- Different implementations might behave differently
- Bugs hide in undefined corners

**Real-world impact:**
- Team A writes implementation that throws NPE
- Team B writes caller expecting return 0
- Neither is "wrong" according to spec
- Bug discovered in production

‚Üí **Transition:** Let's see how to fix this...
</aside>

</Slide>

<Slide>

## Every Input Needs Defined Behavior

<p style={{fontSize: '0.85em', color: '#27ae60'}}>
  ‚úì Sufficiently restrictive:
</p>

```java
/**
 * Calculates the sum of the elements.
 * @param arr the elements
 * @return the sum of the elements, or 0 if arr is empty
 * @throws NullPointerException if arr is null
 */
public int sum(int[] arr)
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Now <strong>every input</strong> has defined behavior:
</p>

<ul style={{fontSize: '0.8em'}}>
  <li>Valid array ‚Üí returns sum</li>
  <li>Null ‚Üí throws NullPointerException</li>
</ul>

<aside className="notes">
**What changed:**
- Added `@throws NullPointerException if the array is null`
- Now callers know EXACTLY what happens for null
- Implementations MUST throw NPE for null (not return 0, not crash)

**The principle:**
- Every possible input should have defined behavior
- Either: specify the result, or specify the error
- Silence = undefined = bugs

**Tip for students:**
- When writing specs, think: "What could callers pass in?"
- For each possibility: "What should happen?"
- Document all of them

‚Üí **Transition:** Here's another example of restrictiveness in the Java standard library...
</aside>

</Slide>

<Slide>

## Silence in a Spec Means Undefined Behavior

<div style={{display: 'flex', gap: '1em', fontSize: '0.85em'}}>
<div style={{flex: 1}}>

‚ùå **Underspecified:**
```java
/**
 * Returns an iterator over
 * the elements in this set.
 * @return an Iterator over the
 *         elements in this set
 */
public Iterator<E> iterator()
```

<p style={{fontSize: '0.8em', color: '#888'}}>
  Client might assume insertion order...
</p>

</div>
<div style={{flex: 1}}>

‚úì **Properly specified:**
```java
/**
 * Returns an iterator over
 * the elements in this set.
 * The elements are returned in
 * no particular order.
 * @return an Iterator over the
 *         elements in this set
 */
public Iterator<E> iterator()
```

</div>
</div>

<aside className="notes">
**The iterator example:**
- Left: client might assume elements come in insertion order
- Right: explicitly states "no particular order"
- Prevents incorrect assumptions

**Why this matters:**
- HashSet iterates in hash-bucket order (essentially random)
- LinkedHashSet iterates in insertion order
- TreeSet iterates in sorted order
- Same interface, different behavior‚Äîspec must clarify!

**Key insight:**
- Restrictiveness is about RULING OUT bad behavior
- Sometimes that means restricting what the CALLER can assume
- "No particular order" = caller can't rely on order

‚Üí **Transition:** But we can go too far‚Äîwhat if we're TOO restrictive?
</aside>

</Slide>

<Slide>

## General Specs Don't Over-Constrain Implementations

<p style={{fontSize: '0.9em'}}>
  A spec is <strong>general</strong> if it doesn't rule out implementations that would be correct.
</p>

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Think of it as: <em>"What GOOD implementations does this spec allow?"</em>
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li>Does it describe WHAT the method does, or HOW?</li>
  <li>Could a faster algorithm satisfy it?</li>
  <li>Does it over-specify implementation details?</li>
</ul>

<aside className="notes">
**The key distinction:**
- Definitional spec: describes the result ("returns the sum")
- Operational spec: describes the steps ("loop through and add each")

**Why generality matters:**
- Allows optimization without breaking contract
- Permits multiple correct implementations
- Future-proofs the API

**The test:**
- Think of different ways to implement this method
- If a correct implementation would violate the spec, it's too restrictive

‚Üí **Transition:** Let's see an example of an overly operational spec...
</aside>

</Slide>

<Slide>

## Operational Specs Reject Valid Implementations

<p style={{fontSize: '0.85em', color: '#e74c3c'}}>
  ‚ùå Too operational (not general):
</p>

```java
/**
 * Finds the index of searchTarget in arr by iterating forward through all
 * elements of the array until finds the value.
 *
 * @param arr an array of increasing values
 * @param searchTarget the element to search for
 * @return the index of arr that contains searchTarget
 * @throws NullPointerException if arr is null
 * @throws NoSuchElementException if arr does not contain searchTarget
 */
public int findIndex(int[] arr, int searchTarget)
```

<aside className="notes">
**The problem:**
- This spec describes HOW to implement, not WHAT the method does
- "Examines each element in order" ‚Äî requires linear search
- "Return the current index" ‚Äî requires returning FIRST occurrence

**Why too restrictive:**
- Binary search would violate this spec (doesn't examine "in order")
- Returning ANY valid index would violate this spec
- But both could be correct for many use cases!

**Operational vs. Definitional:**
- Operational: describes steps to execute
- Definitional: describes the result/effect
- Specs should be definitional (what), not operational (how)

‚Üí **Transition:** Let's see the general version...
</aside>

</Slide>

<Slide>

## Describe Results, Not Algorithms

<p style={{fontSize: '0.85em', color: '#27ae60'}}>
  ‚úì Sufficiently general:
</p>

```java
/**
 * Finds the index of arr that contains searchTarget.
 *
 * @param arr an array of increasing values
 * @param searchTarget the element to search for
 * @return the index of arr that contains searchTarget
 * @throws NullPointerException if arr is null
 * @throws NoSuchElementException if arr does not contain searchTarget
 */
public int search(int[] arr, int searchTarget)
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  This permits: linear search, binary search, random probing, first/last/any index...
</p>

<aside className="notes">
**What changed:**
- No mention of HOW to search
- Same restrictiveness for error cases

**Benefits:**
- Implementer can choose best algorithm
- Caller knows what to expect: a valid index, or an exception
- Future optimization won't break the contract

**Rule of thumb:**
- Describe the result (what you get)
- Not the algorithm (how you get it)
- Unless the algorithm IS the requirement

‚Üí **Transition:** But what if we really DO need the first index?
</aside>

</Slide>

<Slide>

## The Right Balance Depends on What Callers Need

<p style={{fontSize: '0.9em'}}>
  Sometimes being more specific IS the right choice:
</p>

```java
/**
 * Finds the index of the first occurrence of searchTarget in arr.
 *
 * @param arr an array of increasing values
 * @param searchTarget the element to search for
 * @return the smallest index i where arr[i] == searchTarget
 * @throws NoSuchElementException if arr does not contain searchTarget
 * @throws NullPointerException if arr is null
 */
public int indexOf(int[] arr, int searchTarget)
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  This is <strong>more restrictive</strong> but <strong>necessarily so</strong> if callers need the first occurrence.
</p>

<p style={{fontSize: '0.85em', marginTop: '0.5em', color: '#9370DB'}}>
  The right balance depends on what callers actually need.
</p>

<aside className="notes">
**The key insight:**
- Generality vs. restrictiveness is a tradeoff
- The "right" balance depends on requirements

**When to be more specific:**
- Callers genuinely need a specific behavior
- The extra constraint enables useful assumptions
- Example: indexOf() vs search()

**When to be more general:**
- Multiple implementations could satisfy callers
- You want flexibility to optimize later
- Example: Collection size vs specific data structure

**The test:**
- Ask: "Do callers need this level of detail?"
- If yes: specify it (restrictiveness)
- If no: leave it open (generality)

‚Üí **Transition:** Now let's look at clarity‚Äîcan readers understand the spec correctly?
</aside>

</Slide>

<Slide>

## The Most Dangerous Specs Are Misunderstood Specs

<p style={{fontSize: '0.9em'}}>
  A spec is <strong>clear</strong> if readers understand it correctly.
</p>

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  The most dangerous specs are those where readers <em>think</em> they understand but don't.
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li><strong>Too brief:</strong> Readers fill in gaps with assumptions</li>
  <li><strong>Too long:</strong> Readers skim and miss important details</li>
  <li><strong>Jargon-heavy:</strong> Readers guess at meaning</li>
  <li><strong>Redundant:</strong> Readers wonder what's different about each statement</li>
</ul>

<aside className="notes">
**The danger:**
- Unclear specs don't just confuse‚Äîthey mislead
- Reader thinks they understand, writes code based on wrong assumption
- Bug only discovered much later

**Clear specs are:**
- Concise (but not too brief)
- Use terms the reader knows
- Define domain-specific terms
- Avoid unnecessary repetition

**The test:**
- Show spec to someone unfamiliar with the code
- Ask them to explain what the method does
- Do their assumptions match reality?

‚Üí **Transition:** Let's see examples of clarity problems...
</aside>

</Slide>

<Slide>

## Redundancy Creates Confusion, Not Clarity

<p style={{fontSize: '0.85em', color: '#e74c3c'}}>
  ‚ùå Redundant (hurts clarity):
</p>

```java
/**
 * Returns the sum of the elements in the array.
 * The sum is computed by adding each element of the array.
 * It is the total of all the elements in the array.
 *
 * @param arr the array to sum
 * @return the sum of the elements in the array
 */
public int sum(int[] arr)
```

<p style={{fontSize: '0.8em', marginTop: '0.5em'}}>
  The reader already knows what "sum" means!
</p>

<aside className="notes">
**Problems with redundancy:**
- Longer to read = higher cognitive load
- Repeated information suggests there might be subtle differences
- Reader wonders: "Why are they explaining 'sum'? Am I missing something?"

**Clear specs are concise:**
- Say it once, say it well
- Don't explain concepts the reader already knows
- Extra words = extra chances for confusion

**But wait:**
- Sometimes redundancy HELPS
- It depends on your audience's knowledge
- Let's see an example where more explanation is better...

‚Üí **Transition:** Sometimes more detail helps‚Äîwhen the concept isn't universally known...
</aside>

</Slide>

<Slide>

## Domain-Specific Terms Need Definitions

<p style={{fontSize: '0.85em', color: '#e74c3c'}}>
  ‚ùå Unclear (assumes domain knowledge):
</p>

```java
/**
 * Computes the present value of an income stream.
 *
 * @param income the annual income
 * @param interestRate the risk-free interest rate
 * @param years the number of years
 * @return the present value of the income stream
 */
public float presentValue(float income, float interestRate, int years)
```

<p style={{fontSize: '0.85em', color: '#27ae60', marginTop: '1em'}}>
  ‚úì Clear (provides context):
</p>

```java
/**
 * Computes the present value of an income stream.
 * The present value is the amount that, if invested at the given
 * interest rate, would grow to the total income over the given years.
 * ...
 */
```

<aside className="notes">
**The problem:**
- "Present value" is a finance term‚Äînot everyone knows it
- Without definition, reader must look it up or guess
- Risk: reader THINKS they understand but doesn't

**The fix:**
- One sentence defining the concept
- Now reader can verify their understanding
- Or learn the concept if they didn't know it

**Balancing act:**
- For "sum"‚Äîdefinition is redundant
- For "present value"‚Äîdefinition is essential
- Know your audience!

**General principle:**
- Define domain-specific terms
- Don't define common programming terms
- When in doubt, err toward clarity

‚Üí **Transition:** Now think about WHO is reading your spec. Have you ever written down a recipe?
</aside>

</Slide>

{/* ============================================ */}
{/* BRIDGE: SPECS SCALE FROM METHODS TO AI */}
{/* ============================================ */}

<Slide>

## The Same Spec Principles Apply at Every Scale

<Img
    src="/img/lectures/web/l4-spec-scales.webp"
    alt="Concept: 'The Recipe Card at Different Scales' (Same Principles, Different Kitchens)

A warm, inviting three-panel illustration showing that recipe-writing principles remain constant whether you're cooking for yourself, running a restaurant, or programming a robot baker. Rendered in a cozy culinary-meets-technical style with consistent visual language across all three scales.

LEFT PANEL - 'HOME KITCHEN' (You as Implementer):
A cozy home kitchen with a handwritten recipe card pinned to the fridge: 'Chocolate Chip Cookies - Mix ingredients, bake until golden.' A home cook (you) stands at the counter, confidently filling in the gaps: thought bubbles show 'I like them crispy,' 'Mom's recipe uses butter not margarine,' 'Golden means 12 minutes in MY oven.' The cookies come out perfect because YOUR context matches YOUR intent. A small note: 'Spec works because you share context with yourself.' Warm, golden lighting. Caption: 'Vague specs work when you implement them yourself.'

CENTER PANEL - 'RESTAURANT KITCHEN' (Team of Humans):
A bustling professional kitchen with multiple cooks at different stations, all reading the SAME recipe card‚Äîbut now it's more detailed: '225g butter (unsalted), 2.5g salt per 100g flour, bake at 177¬∞C for 11 minutes.' Different cooks have different thought bubbles showing their interpretations: Cook A thinks 'golden brown = deep amber,' Cook B thinks 'golden brown = light tan,' Cook C (new hire) thinks 'wait, what's golden brown?' Some cookies come out perfect, some burnt, some underdone. A quality control inspector looks frustrated. Note: 'Same spec, different contexts, different results.' Caption: 'More implementers = more interpretations.'

RIGHT PANEL - 'ROBOT BAKER' (AI/Automated System):
A gleaming automated bakery line with a robot arm and conveyor belt. The recipe is now a detailed specification document: 'Bake until internal temp reaches 93¬∞C AND surface reflectance measures 0.35 on colorimeter AND elapsed time ‚â• 10 min. If flour hopper < 500g, HALT and alert. If oven temp deviates > 2¬∞C, compensate by...' The robot executes EXACTLY what's specified‚Äîno more, no less. One batch shows perfect cookies. Another batch shows the robot has stopped mid-production because the spec said 'halt' but didn't say what to do after refilling flour. An engineer scratches their head: 'It did exactly what we said...' Caption: 'AI/automation executes literally. Every gap becomes a decision point.'

BOTTOM UNIFYING ELEMENT:
A horizontal strip showing the same three principles (Restrictive, General, Clear) as measuring cups that appear in all three kitchens‚Äîsame tools, different scales. Central message: 'The recipe-writing principles don't change. The consequences of ambiguity do. A vague instruction like 'bake until done' works when YOU'RE baking‚Äîbut fails at scale.'

THE TWIST (Important callout box):
Shows the home cook returning to their kitchen 6 months later, following their own vague recipe... and the cookies come out wrong. Thought bubble: 'Wait, did I used to bake these at 350 or 375? What did I mean by golden?' Caption: 'Plot twist: Even YOUR context changes over time. Future-you is also a different implementer.'

BOTTOM TAGLINE:
'Every implementer‚Äîincluding yourself tomorrow‚Äîfills gaps with their own context. The question isn't WHO interprets your spec. It's whether your spec eliminated the wrong interpretations.'

Style: Warm bakery aesthetic with rich browns, warm yellows, and cream colors. Each panel should feel progressively more industrial/technical while maintaining the cooking metaphor. The home kitchen is cozy and personal, the restaurant is professional but human, the robot bakery is precise and clinical. Should feel like a relatable story that makes students think: 'Oh, I've been that home cook who couldn't follow my own recipe later!'"
  />

<aside className="notes">
**The recipe metaphor:**
- Everyone's written a vague recipe that worked... for them, that day
- But try handing that recipe to someone else, or following it 6 months later
- Same problem with code specs!

**Home kitchen (you as implementer):**
- "Bake until golden" works because YOU know what golden means to YOU
- Your context matches your intent perfectly
- This is why quick personal scripts don't need elaborate docs

**Restaurant kitchen (team of humans):**
- Same recipe, 5 cooks, 5 interpretations of "golden brown"
- One cook's "golden" is another's "burnt"
- The new hire has NO context‚Äîwhat even IS golden brown?
- This is enterprise software: same spec, different developers, different results

**Robot baker (AI/automation):**
- Must specify EVERYTHING: exact temperatures, sensor readings, error handling
- Robot does EXACTLY what you say‚Äîno more, no less
- "Halt if flour low" ‚Üí robot halts... forever, because you didn't say what happens AFTER refilling
- AI is the same: fills gaps with training data patterns, might be totally wrong for YOUR context

**The twist (key insight!):**
- Ask students: "Ever tried to follow your own recipe months later?"
- YOUR context changes too! Future-you is also a different implementer
- This is why we document code‚Äîeven for ourselves

**The real lesson:**
- It's not "humans good, AI bad"
- ALL implementers fill gaps with their own context
- AI just makes this visible FASTER (and with more surprising context)
- Good specs protect you from everyone‚Äîincluding yourself tomorrow

**Connection to later course:**
- Lecture 13: AI-Assisted Development
- You'll write specs (prompts) for AI assistants
- Same skills, faster feedback loop

‚Üí **Transition:** Let's see what happens when ambiguous specs compound over time...
</aside>

</Slide>

<Slide>

## "Process" and "Handle" Are Not Specifications

<p style={{fontSize: '0.9em'}}>
  Consider this seemingly reasonable API:
</p>

```java
/**
 * Processes the given payment.
 *
 * @param payment the payment to process
 * @throws PaymentException if the payment cannot be processed
 */
public void processPayment(Payment payment)
```

<p style={{fontSize: '0.85em', marginTop: '1em', color: '#e74c3c'}}>
  What does "process" actually mean? Every implementer fills the gap differently.
</p>

<ul style={{fontSize: '0.75em', marginTop: '0.5em'}}>
  <li>Validate the amount? Charge the card? Send confirmation email?</li>
  <li>What if partially successful? Retry on failure?</li>
  <li>Idempotent if called twice? Timeout behavior?</li>
</ul>

<aside className="notes">
**The "process" trap:**
- "Process" is a verb that sounds specific but isn't
- Same problem with: handle, manage, deal with, take care of
- These words delegate ALL decisions to the implementer

**Both humans AND AI fill gaps with context:**
- Human implementer: fills gaps with domain knowledge, past experience, assumptions about "reasonable" behavior
- AI implementer: fills gaps with training data patterns, which might be from a completely different domain
- BOTH might be wrong! The human's context might not match the spec writer's intent either

**The key insight:**
- It's not "humans right, AI wrong"
- It's "ambiguous specs ‚Üí unpredictable implementations"
- AI just makes this visible FASTER and with DIFFERENT (often surprising) context
- A human with wrong domain assumptions is just as dangerous‚Äîjust slower

**The fix preview:**
- Define WHAT happens, not just that something happens
- Every edge case needs explicit behavior
- "Process" should become 5-10 specific requirements

**Real examples (human AND AI):**
- "Handle the error appropriately" ‚Üí Junior dev logs and continues, senior dev halts (who's right?)
- "Send the notification" ‚Üí One team sends immediately, another batches (spec didn't say!)
- AI just produces these mismatches in seconds instead of days

‚Üí **Transition:** Unclear specs have long-term costs beyond immediate confusion...
</aside>

</Slide>

<Slide>

## Ambiguity Creates Specification Debt

<Img
    src="/img/lectures/web/l4-spec-debt.webp"
    alt="Concept: 'The Hidden Decision Factory' (How Ambiguous Specs Create Unintended Consequences)

An illustrated factory scene showing how ambiguous specifications lead to hidden, consequential decisions being made by implementers.

THE AMBIGUOUS SPEC:
A vague specification document enters the factory on a conveyor belt. It reads: 'Process submissions promptly.' A magnifying glass hovers over it showing NO details about: ordering, fairness, priority, timing. The document has a 'SEEMS FINE' stamp but is leaking question marks.

THE DECISION FACTORY:
Inside the factory, a developer stands at a workstation with multiple levers and buttons‚Äîeach representing a DECISION the spec didn't make:
- Lever 1: 'Processing Order?' (alphabetical / random / first-come / priority-based)
- Lever 2: 'What is prompt?' (1 second / 1 minute / 1 hour)
- Lever 3: 'Handle ties how?' (arbitrary / fair rotation)
The developer shrugs and pulls levers somewhat randomly: 'The spec didn't say... I'll just do alphabetical. Seems reasonable?'

THE UNINTENDED CONSEQUENCE:
The factory output shows a queue of student submissions being processed. Students named 'Adams', 'Baker', 'Chen' get processed quickly (shown smiling, timer showing '2 min wait'). Students named 'Williams', 'Young', 'Zhang' wait much longer (shown frustrated, timer showing '45 min wait'). A fairness meter shows a red warning. Caption: 'Alphabetical ordering = systematic disadvantage for names late in alphabet. Developer didn't intend this. Spec didn't prevent it.'

THE HIDDEN COST:
A timeline showing:
- 'SPEC PHASE: Fix ambiguity for $100' (small, easy)
- 'DEV PHASE: Fix ambiguity for $1,000' (medium, refactoring)
- 'PRODUCTION: Fix ambiguity for $100,000' (huge‚Äîuser complaints, legal review, PR crisis, data migration)
Caption: 'Specification debt compounds like financial debt. The longer you wait, the more expensive the fix.'

THE LESSON:
'Ambiguous specs don't eliminate decisions‚Äîthey delegate them to people who don't realize they're making them. Hidden decisions become invisible assumptions become unintended consequences.'

Style: Whimsical factory/Rube-Goldberg aesthetic with clear cause-and-effect flow. Show the chain from 'vague spec' ‚Üí 'arbitrary implementation choice' ‚Üí 'real-world unfairness'. Color palette: grays and browns for the ambiguous input, increasingly alarming reds for the consequences. Should feel like a cautionary tale that makes students want to clarify their specs upfront."
  />


<aside className="notes">
**The hidden cost:**
- Ambiguous spec ‚Üí implementation decision
- Developer might not realize they're choosing
- Choice becomes embedded in shipped code
- Users affected by "accidental" decisions

**The grading example:**
- "Promptly" is vague‚Äîdoesn't specify order
- Alphabetical is a reasonable implementation choice
- But it has fairness implications the spec didn't consider
- Now changing it requires refactoring + explaining to users

**Specification debt:**
- Like technical debt, but in the contract
- Works fine initially, creates liability over time
- More users = more diverse expectations = more debt

**Prevention:**
- Ask: "Could different interpretations lead to different outcomes for different groups?"
- Resolve ambiguity BEFORE implementation

‚Üí **Transition:** So far we've written specs as comments. Can we do better?
</aside>

</Slide>

{/* ============================================ */}
{/* ARC 3: TYPE ANNOTATIONS */}
{/* ============================================ */}

<Slide>

## Type Annotations Let Compilers Enforce Specs

<Img
    src="/img/lectures/web/l4-type-annotations.webp"
    alt="Concept: 'The Factory Quality Control Line' (Comments vs Type Annotations)

A detailed factory floor illustration in a clean industrial design style, showing two parallel assembly lines for 'Method Calls' being quality-checked before shipping to production.

LEFT LINE - 'HONOR SYSTEM QUALITY CONTROL' (Comment-Only Specs):
A conveyor belt carrying method calls (visualized as packages labeled with their arguments). A laminated sign hangs above: 'üìã PLEASE CHECK: arr should not be null - Javadoc says so!' A tired human inspector sits on a stool, barely glancing at packages as they roll by. One package clearly labeled 'null' rolls past‚Äîthe inspector is looking at their phone. Behind the inspection point: CHAOS. Packages explode on contact with the 'Production' area (labeled 'Runtime'), sparks fly, a NullPointerException alarm blares, developers in hard hats scramble with fire extinguishers. A whiteboard shows: 'Days since last null crash: 0Ã∂ Ã∂3Ã∂ Ã∂7Ã∂ 0'. Annotation: 'Comments are suggestions. Humans skip reading them. Bugs ship to production.'

RIGHT LINE - 'AUTOMATED QUALITY GATE' (Type Annotations):
The same conveyor belt, but now it passes through an imposing automated scanner (glowing, precise, robotic). The scanner display shows: '@NonNull int[] arr ‚Äî SCANNING...' Valid packages (with proper non-null arrays) get a green checkmark stamp and proceed smoothly to 'Production'. But the 'null' package hits an invisible force field‚Äîred lights flash, the scanner announces 'REJECTED: null violates @NonNull constraint', and the package is automatically diverted to a 'Fix Before Shipping' chute that loops back to the developer's desk. Beyond the gate: calm, orderly production floor. A whiteboard shows: 'Days since last null crash: 847'. Annotation: 'Type annotations are machine-enforced. Bugs caught before shipping.'

CENTER COMPARISON PANEL:
Split view showing the same code:
- Top: '// @param arr must not be null' + 'sum(null);' ‚Üí Package makes it to production ‚Üí üí• RUNTIME CRASH
- Bottom: '@NonNull int[] arr' + 'sum(null);' ‚Üí Package rejected at compile time ‚Üí üîß Developer fixes it

DETAIL CALLOUTS:
- On the scanner: 'Powered by NullAway + JSpecify' with small logos
- Developer reaction left: üò∞ 'Why did this crash in production at 3am?!'
- Developer reaction right: üòä 'Caught it before I even ran the tests'

BOTTOM:
A timeline showing: 'Java 8 (2014): Type annotations added' with small portraits of the UW researchers. Caption: 'Moving specs from comments (that humans ignore) to types (that compilers enforce).'

Style: Industrial factory aesthetic with warm yellows/oranges on the chaotic left side, cool blues/greens on the orderly right side. Clean lines, clear labels, immediate visual contrast. Should feel like a safety training poster that makes a compelling case for type annotations. The factory metaphor works because it emphasizes: quality control BEFORE shipping is cheaper than recalls AFTER."
  />

<p style={{fontSize: '0.85em', marginTop: '0.5em'}}>
  Type annotations let the <strong>compiler</strong> enforce specification invariants.
</p>

<aside className="notes">
**The problem with comments:**
- Javadoc says "arr must not be null"
- But caller can pass null anyway
- Error only discovered at runtime (if you're lucky)

**Type annotations (Java 8+):**
- Researchers at University of Washington proposed this
- One of few academic contributions accepted into Java
- Annotations on types, not just declarations

**The benefit:**
- Compiler checks nullness at compile time
- Error before the code even runs
- Documentation AND enforcement in one

‚Üí **Transition:** Let's see how to use nullness annotations in practice...
</aside>

</Slide>

<Slide>

## @NonNull Turns Documentation Into Enforcement

```java
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public int sum(@NonNull int[] arr) {
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  With <code>@NonNull</code>, the compiler enforces that <code>arr</code> is never null.
</p>

<p style={{fontSize: '0.8em', marginTop: '0.5em', color: '#888'}}>
  Note: Java has many competing <code>@NonNull</code> definitions. We use <a href="https://jspecify.dev/">JSpecify</a>.
</p>

<aside className="notes">
**JSpecify:**
- Coalition: Google, JetBrains, Microsoft, Uber, Oracle
- Standard nullness annotations (finally!)
- Used with NullAway checker in this course

**What changes:**
- `@NonNull` = this parameter/return/field is never null
- `@Nullable` = this CAN be null, handle it
- Compiler error if you pass null to @NonNull

**The annotation mess:**
- javax.annotation.NonNull, org.jetbrains.annotations.NotNull, etc.
- Each tool had its own definition
- JSpecify standardizes this (we hope)

‚Üí **Transition:** Writing @NonNull everywhere gets tedious. There's a better approach...
</aside>

</Slide>

<Slide>

## @NullMarked Makes Non-Null the Default

<p style={{fontSize: '0.9em'}}>
  Mark the whole package as "non-null by default":
</p>

```java
// In package-info.java
@NullMarked
package edu.neu.cs3100.myproject;

import org.jspecify.annotations.NullMarked;
```

<p style={{fontSize: '0.9em', marginTop: '1em'}}>
  Now only mark exceptions with <code>@Nullable</code>:
</p>

```java
// In a @NullMarked package:
public int sum(int[] arr) { ... }  // arr assumed non-null

public String format(@Nullable String prefix, String value) { ... }
// prefix can be null, value cannot
```

<aside className="notes">
**The pattern:**
1. Add @NullMarked to package-info.java
2. All types in that package are non-null by default
3. Only annotate things that CAN be null with @Nullable

**Why this is better:**
- Most types are non-null in practice
- Less annotation clutter
- Explicit about the exceptional cases

**For this course:**
- New projects use @NullMarked
- You'll see this in starter code
- Add @Nullable only when needed

‚Üí **Transition:** Let's see what this looks like in a real method...
</aside>

</Slide>

<Slide>

## Annotations Make Nullability Explicit at a Glance

```java
// In a @NullMarked package

/**
 * Formats a user's display name.
 *
 * @param firstName the user's first name
 * @param middleName the user's middle name, or null if none
 * @param lastName the user's last name
 * @return formatted name (such as "John Q. Public")
 */
public String formatName(
    String firstName,            // non-null (default)
    @Nullable String middleName, // explicitly nullable
    String lastName              // non-null (default)
) {
    if (middleName == null) {
        return firstName + " " + lastName;
    }
    return firstName + " " + middleName.charAt(0) + ". " + lastName;
}
```

<aside className="notes">
**What the annotations tell us:**
- firstName: required, cannot be null
- middleName: optional, might be null
- lastName: required, cannot be null
- Return: always non-null (default in @NullMarked)

**The compiler enforces:**
- Caller must provide non-null firstName and lastName
- Caller can pass null for middleName
- Method must check middleName before using it
- Method must return non-null

**Compare to just Javadoc:**
- Javadoc says "middleName, or null if none"
- But nothing enforces the caller reads this
- @Nullable makes it compiler-checked

‚Üí **Transition:** What about working with existing code that isn't annotated?
</aside>

</Slide>

<Slide>

## Legacy Code Requires Gradual Annotation Adoption

<p style={{fontSize: '0.9em'}}>
  Two approaches for existing codebases:
</p>

<div style={{display: 'flex', gap: '1em', marginTop: '1em', fontSize: '0.8em'}}>
<div style={{flex: 1}}>

**Approach A: @NullMarked (new code)**
- Mark new packages @NullMarked
- Existing code left unannotated
- Gradually migrate package by package

</div>
<div style={{flex: 1}}>

**Approach B: @NonNull everywhere (legacy)**
- Don't use @NullMarked
- Add @NonNull as you verify each type
- Safer but more verbose

</div>
</div>

<p style={{fontSize: '0.85em', marginTop: '1em', color: '#9370DB'}}>
  For this course: new projects use @NullMarked. You'll see this in starter code.
</p>

<aside className="notes">
**For new code (this course):**
- Always use @NullMarked on your packages
- Fewer annotations, cleaner code
- Only add @Nullable when needed

**For legacy code (industry):**
- Often can't add @NullMarked to existing packages
- Would require auditing every type
- Gradual @NonNull approach is safer

**The future:**
- JSpecify + NullAway are gaining adoption
- Eventually most Java code may be null-checked
- Skills you learn now will be valuable

**Active research area:**
- Beyond nullness: immutability annotations, ownership types
- Making more invariants machine-checkable

‚Üí **Transition:** But what about calling code that ISN'T annotated?
</aside>

</Slide>

<Slide>

## Unannotated Libraries Need Runtime Assertions

<p style={{fontSize: '0.9em'}}>
  Even <code>java.util</code> isn't fully annotated! The checker can't know if library methods return null.
</p>

```java
String name = "Alice";
List<String> names = List.of(name); // Checker: "might be null!"
System.out.println(names.size()); // Warning!
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Use <code>Objects.requireNonNull</code> to assert your domain knowledge:
</p>

```java
List<String> names = Objects.requireNonNull(List.of(name));
// Checker now knows names is non-null
```

<aside className="notes">
**The problem:**
- You call List.of() which NEVER returns null (it's documented!)
- But the checker doesn't know‚ÄîJava standard library isn't annotated
- You get a warning even though your code is correct

**Objects.requireNonNull does two things:**
1. Tells the nullness checker "I guarantee this is non-null"
2. Fails fast with clear NPE if you're wrong (instead of confusing error later)

**When to use it:**
- Calling standard library methods like List.of(), Set.of(), Map.of() that never return null
- Calling library methods documented as non-null
- Receiving values from unannotated third-party code

**Caution:**
- Don't use it to silence warnings you don't understand
- If unsure whether something can be null, add a proper null check
- requireNonNull is for when YOU know it's non-null but the CHECKER doesn't
- DON'T use it for methods like Map.get() that genuinely CAN return null‚Äîthat needs real null handling

‚Üí **Transition:** Beyond nullness, Java has other standard contracts‚Äîlet's look at the ones every Object has...
</aside>

</Slide>

{/* ============================================ */}
{/* ARC 4: COMMON OBJECT CONTRACTS */}
{/* ============================================ */}

<Slide>

## Every Java Object Inherits Four Key Contracts

<p style={{fontSize: '0.9em'}}>
  Every class extends <code>java.lang.Object</code>, which defines methods you should consider overriding:
</p>

<ul style={{fontSize: '0.85em', marginTop: '1em'}}>
  <li><code>toString()</code> ‚Äî human-readable representation</li>
  <li><code>equals(Object)</code> ‚Äî logical equality</li>
  <li><code>hashCode()</code> ‚Äî hash value for collections</li>
</ul>

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  Plus the <code>Comparable</code> interface:
</p>

<ul style={{fontSize: '0.85em'}}>
  <li><code>compareTo(T)</code> ‚Äî natural ordering</li>
</ul>

<aside className="notes">
**Why these matter:**
- toString: debugging, logging
- equals: comparing objects, Set membership, List.contains()
- hashCode: HashMap keys, HashSet membership
- compareTo: sorting, TreeSet, TreeMap

**The contracts are interdependent:**
- If you override equals, you MUST override hashCode
- compareTo should be consistent with equals
- Getting these wrong causes subtle, hard-to-find bugs

**Source:**
- "Effective Java" by Joshua Bloch has excellent coverage
- Items 10-14 cover these methods in detail

‚Üí **Transition:** Let's start with the simplest one‚ÄîtoString...
</aside>

</Slide>

<Slide>

## toString Should Be Concise But Informative

<p style={{fontSize: '0.9em'}}>
  From the Java documentation:
</p>

<blockquote style={{fontSize: '0.8em', fontStyle: 'italic', borderLeft: '3px solid #9370DB', paddingLeft: '1em'}}>
  "Returns a string that textually represents this object. The result should be a concise but informative representation that is easy for a person to read."
</blockquote>

<div style={{display: 'flex', gap: '1em', marginTop: '1em', fontSize: '0.8em'}}>
<div style={{flex: 1}}>

**Default (useless):**
```
DimmableLight@1a2b3c4d
```

</div>
<div style={{flex: 1}}>

**Overridden (helpful):**
```
DimmableLight(color=2700K,
  brightness=100, on=true)
```

</div>
</div>

<aside className="notes">
**The default:**
- Class name + "@" + hex hash code
- Essentially useless for debugging
- Tells you the type but nothing about state

**The contract is flexible:**
- "Concise but informative"
- OK to change between versions
- OK to return different strings for same object state

**Always override toString:**
- Called by println, logging, debugger
- Good toString methods save hours of debugging

‚Üí **Transition:** Let's see implementation tips...
</aside>

</Slide>

<Slide>

## Good toString Saves Hours of Debugging

```java
@Override
public String toString() {
    return "DimmableLight(color=" + color + "K, " +
           "brightness=" + brightness + ", " +
           "on=" + on + ")";
}
```

<p style={{fontSize: '0.85em', marginTop: '1em'}}>
  <strong>Best practices:</strong>
</p>

<ul style={{fontSize: '0.8em'}}>
  <li>Include the class name</li>
  <li>Include fields that matter for understanding the object</li>
  <li>Format for readability (not just dump all fields)</li>
  <li>Consider what you'd want to see in a stack trace or debugger</li>
</ul>

<aside className="notes">
**Format considerations:**
- Include class name (helps when logging collections)
- Show key fields with their names
- Omit derived/computed values unless important
- Keep it single-line for log readability (usually)

**Common patterns:**
- ClassName(field1=value1, field2=value2)
- ClassName[field1=value1, field2=value2]
- IDE can generate these for you

**What NOT to do:**
- Don't include passwords or sensitive data
- Don't make it too long (logs become unreadable)
- Don't include mutable state that changes frequently

‚Üí **Transition:** Now let's look at equals‚Äîit's more complex and more critical...
</aside>

</Slide>

{/* Begin discussion of equals() */}
<Slide>

## What does this print (==)?

<PollSlide
  code={`
    public class Student {
        private String name;
        private int nuid;

        public Student(String name, int nuid) {
            this.name = name;
            this.nuid = nuid;
        }

        public static void main(String[] args) {
            Student s1 = new Student("Alex", 1234567);
            Student s2 = new Student("Alex", 1234567);
            System.out.println(s1 == s2);
        }
    }
  `}
  choices={["true", "false", "I have no idea"]}
/>

</Slide>


<Slide>

## What does this print (equals()) ?

<PollSlide
  code={`
    public class Student {
        private String name;
        private int nuid;

        public Student(String name, int nuid) {
            this.name = name;
            this.nuid = nuid;
        }

        public static void main(String[] args) {
            Student s1 = new Student("Alex", 1234567);
            Student s2 = new Student("Alex", 1234567);
            System.out.println(s1.equals(s2));
        }
    }
  `}
  choices={["true", "false", "I have no idea"]}
/>

</Slide>

<Slide>

## Where does `equals()` come from?

<div style={{display: 'flex', gap: '2em', alignItems: 'flex-start', marginTop: '1em'}}>

<div style={{flex: 1}}>
```mermaid
classDiagram
    Object <|-- Student
    class Object {
        +equals(Object obj) boolean
        +hashCode() int
        +toString() String
    }
    class Student {
        -String name
        -int nuid
    }
```

</div>

<div style={{flex: 1}}>

**Object's implementation:**
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```


</div>

</div>

<p style={{fontSize: '0.9em'}}>Since `Student` doesn't override `equals()`, it inherits this version‚Äîwhich just checks reference equality.</p>

</Slide>

<Slide>

## Overriding `equals()`

```java
public class Student {
    private String name;
    private int nuid;

    public Student(String name, int nuid) {
        this.name = name;
        this.nuid = nuid;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Student other)) return false;
        return nuid == other.nuid
            && Objects.equals(name, other.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, nuid);
    }
}
```

<p style={{fontSize: '0.75em', marginTop: '0.5em'}}>What's hashCode()?</p>

</Slide>

<Slide>

## hashCode Enables O(1) Lookup in HashSets and HashMaps

<Img
    src="/img/lectures/web/l4-hashcode-buckets.webp"
    alt="Concept: 'The Hash Table Post Office' (How hashCode and equals Work Together)

A detailed post office / mail sorting facility illustration showing how HashMap finds objects in O(1) time.

THE MAIL SORTING FACILITY:
A bird's-eye view of a mail sorting center with numbered bins (0-15, representing hash buckets). Each bin can hold multiple packages (objects).

STEP 1 - COMPUTING THE HASH:
A package (DimmableLight object) arrives at the 'Hash Calculator' station‚Äîa machine that examines the object's fields (color=2700, brightness=100, on=true) and produces a number. The machine display shows: 'hashCode() ‚Üí 234789234 ‚Üí mod 16 ‚Üí Bucket 7'. An arrow shows the package being directed toward Bucket 7. Annotation: 'hashCode() tells us WHICH bucket to check‚Äîlike a ZIP code for objects.'

STEP 2 - FINDING THE BUCKET:
Bucket 7 is highlighted, showing it contains 3 packages (objects with the same hash). Each package has a label showing its identity. A postal worker (the equals() method) stands at the bucket, examining each package one by one. Annotation: 'Multiple objects can have the same hashCode (collision). That's fine‚Äîbuckets can hold several.'

STEP 3 - THE EQUALS CHECK:
The postal worker compares the incoming package against each package in the bucket using equals(). Two packages don't match (red X). One matches exactly (green ‚úì)! The worker calls out: 'Found it! This is the one.' Annotation: 'equals() confirms exact identity within the bucket‚Äîlike checking the full address, not just ZIP code.'

BOTTOM COMPARISON - O(1) vs O(n):
Left: 'Without hashCode: Check EVERY object in the collection' ‚Äî shows searching through 1000 packages one by one. Time: O(n).
Right: 'With hashCode: Go directly to bucket, check only 2-3 objects' ‚Äî shows jumping to bucket 7 and checking 3 items. Time: O(1) average.

KEY INSIGHT CALLOUT:
'hashCode = fast, approximate (which bucket?)'
'equals = slow, exact (is this the one?)'
'BOTH are needed. hashCode narrows the search; equals confirms the match.'

THE CONTRACT WARNING:
Shows what happens when equals and hashCode disagree (red alert box):
- Two 'equal' objects with different hashCodes ‚Üí they go to different buckets ‚Üí 'light2' is in bucket 7, but 'light1' (which equals light2) is in bucket 3 ‚Üí search for light1 looks in bucket 3, never finds light2 ‚Üí 'OBJECT DISAPPEARED!'
A small diagram shows the failed lookup, with the object seemingly vanishing. Caption: 'If equal objects have different hashCodes, HashMap BREAKS.'

Style: Warm, friendly postal/logistics aesthetic with clear numbering, organized bins, and helpful workers. Color-code the buckets, highlight the 'found' path in green. Should make the two-phase lookup (hash ‚Üí bucket ‚Üí equals ‚Üí found) crystal clear. The post office metaphor works because everyone understands: ZIP code gets you to the right area, then you need the full address to find the exact house."
  />

<aside className="notes">
**How hash collections work:**
- Objects sorted into "buckets" by hashCode
- Each bucket is a small list
- To find an object: compute hash ‚Üí go to bucket ‚Üí linear search with equals()

**Why both are needed:**
- hashCode: fast, approximate (which bucket?)
- equals: slow, exact (is this the one?)
- hashCode narrows the search, equals confirms

**The contract connection:**
- Equal objects MUST have equal hash codes
- Otherwise: object in wrong bucket ‚Üí never found
- This is why overriding equals requires overriding hashCode

‚Üí **Transition:** Let's look at the hashCode contract...
</aside>

</Slide>

<Slide>

## Why override `hashCode()`?

<p className="fragment">`Object`'s implementation of `hashCode()` returns a value based on the object's memory address.</p>

<p className="fragment">Can two different objects have the same memory address? <strong className="fragment">No.</strong></p>

<div className="fragment">

```java
// Student with equals() but NO hashCode() override
Student s1 = new Student("Alex", 1234567); // hashCode is memory address
Student s2 = new Student("Alex", 1234567); // hashCode is different address

System.out.println(s1.equals(s2));  // true

Set<Student> set = new HashSet<>();
set.add(s1); // s1 is placed in bucket based on its memory address
System.out.println(set.contains(s2));  // false!
```

</div>

<p className="fragment" style={{fontSize: '0.8em', marginTop: '0.5em'}}><strong>The problem:</strong> `s1` and `s2` are equal, but have different hash codes, so `HashSet` looks in the wrong bucket.</p>

</Slide>

{/* Slide 2: equals() comparison */}

<Slide>

## Equal Objects Must Have Equal hashCode() Values

<p style={{fontSize: '0.9em'}}>
  The contract (simplified):
</p>

<ul style={{fontSize: '0.85em'}}>
  <li><strong>Required:</strong> If <code>x.equals(y)</code>, then <code>x.hashCode() == y.hashCode()</code></li>
  <li><strong>Recommended:</strong> If <code>!x.equals(y)</code>, hash codes <em>should</em> differ</li>
  <li><strong>Required:</strong> Consistent within one execution</li>
</ul>

<p style={{fontSize: '0.9em', marginTop: '1em', color: '#e74c3c'}}>
  ‚ö†Ô∏è If you override <code>equals</code>, you <strong>must</strong> override <code>hashCode</code>!
</p>

<aside className="notes">
**The critical rule:**
- Equal objects MUST have equal hash codes
- Otherwise HashMap/HashSet break completely

**The recommendation:**
- Unequal objects SHOULD have different hash codes
- If all objects have same hash code, HashMap becomes a linked list
- O(1) lookup becomes O(n)

**What the contract allows:**
- Unequal objects CAN have same hash code (collision)
- hashCode can change between JVM executions
- hashCode should NOT change during one execution

‚Üí **Transition:** Here's how to implement hashCode...
</aside>

</Slide>

<Slide>

## Use the Same Fields in hashCode as in equals

```java
@Override
public int hashCode() {
    int result = Integer.hashCode(nuid);
    result = 31 * result + Objects.hashCode(name);
    return result;
}

// Or simply:
@Override
public int hashCode() {
    return Objects.hash(name, nuid);
}
```

<p style={{fontSize: '0.8em', marginTop: '0.5em'}}>
  Use the <strong>same fields</strong> as <code>equals</code>. See <em>Effective Java</em> Item 11 for details.
</p>

<aside className="notes">
**The recipe:**
1. Start with hashCode of first field
2. Combine: 31 * result + nextField.hashCode()
3. Return result

**Why 31?**
- Prime number (reduces collisions)
- 31 * x can be optimized to (x &lt;&lt; 5) - x
- Traditional Java choice

**The easy way:**
- Objects.hash(field1, field2, ...) does this for you
- Slightly slower (creates array) but correct
- Use for non-performance-critical code

**Key rule:**
- Same fields in equals ‚Üí same fields in hashCode
- If a field affects equality, it must affect hash code
</aside>

</Slide>

<Slide>

## Sorting with the Comparable Interface

<Img src="/img/lectures/web/l4-comparable.png"
prompt="Concept: 'The Universal Sorting Machine' (How Comparable Plugs Into Collections)
A detailed factory/assembly line illustration showing how sorting and searching algorithms work with any Comparable object.
THE SORTING FACTORY:
A large industrial facility with a prominent machine in the center labeled 'Collections.sort()' with a secondary machine nearby labeled 'Collections.binarySearch()'. Both machines have identical, standardized input ports shaped like electrical outlets, labeled 'Comparable<T>'.
THE STANDARDIZED INTERFACE:
Close-up of the input port showing its shape‚Äîa plug socket with two prongs labeled 'compareTo()' and 'consistent ordering'. A sign above reads: 'ANY object welcome‚Äîas long as you have the right plug!' Annotation: 'The algorithm doesn't care WHAT you are, only that you can answer: 'Are you less than, equal to, or greater than this other object?''
THE PARADE OF OBJECTS:
A conveyor belt brings diverse objects toward the machine, each holding an identical plug (their Comparable implementation):

A String 'apple' with a plug showing 'compareTo() ‚Üí alphabetical order'
An Integer 42 with a plug showing 'compareTo() ‚Üí numeric order'
A Student object (name='Alex', nuid=1234567) with a plug showing 'compareTo() ‚Üí by NUID'
A custom 'HighScore' object with a plug showing 'compareTo() ‚Üí by points descending'
Each object is different, but all plugs fit the same socket. Annotation: 'Every class decides its OWN natural ordering‚ÄîString uses alphabetical, Integer uses numeric, you choose what makes sense for your class.'
INSIDE THE MACHINE:
A cutaway view showing the sorting algorithm at work. The machine's internal logic is simple‚Äîjust a series of compareTo() calls represented as a judge holding up cards: '-1' (less than), '0' (equal), '+1' (greater than). The judge doesn't see the objects themselves, only the answers. Annotation: 'The algorithm is GENERIC. It just asks compareTo() over and over until everything is sorted.'
THE OUTPUT:
Objects emerge from the machine in perfect order. A display shows:

Strings: 'apple', 'banana', 'cherry'
Integers: 1, 2, 3, 42, 100
Students: sorted by NUID
Caption: 'Same machine, same algorithm, different types‚Äîall sorted correctly.'
BOTTOM COMPARISON - With vs Without Comparable:
Left: 'Without Comparable: Write a new sorting method for EVERY type' ‚Äî shows a frustrated programmer surrounded by duplicate code: sortStrings(), sortIntegers(), sortStudents(), sortHighScores()... Caption: 'Repetitive, error-prone, exhausting.'
Right: 'With Comparable: ONE sort method works for ALL types' ‚Äî shows the single elegant machine accepting everything. Caption: 'Write compareTo() once, get sorting and searching for free.'
THE CONTRACT CALLOUT:
A warning sign showing the rules:

'sgn(x.compareTo(y)) == -sgn(y.compareTo(x))' ‚Üí illustrated as a reversible arrow
'Transitive: if a < b and b < c, then a < c' ‚Üí illustrated as three objects in a chain
'Consistent with equals (recommended)' ‚Üí shows compareTo() returning 0 exactly when equals() returns true
Caption: 'Break these rules and the machine jams‚Äîobjects end up in random order!'
KEY INSIGHT CALLOUT:
'Comparable = a PROMISE that your object can be ordered'
'compareTo() = the METHOD that defines that ordering'
'Algorithms don't sort objects‚Äîthey sort Comparables. Your class just needs to speak the language.'
Style: Clean, friendly industrial aesthetic with color-coded conveyor belts, satisfying plug-and-socket connections, and a sense of elegant machinery. The plugs should look identical across all object types to emphasize the uniform interface. Highlight the 'aha moment' that one algorithm works for infinite types. Should make polymorphism feel practical and empowering rather than abstract."
alt="An educational infographic titled 'The Universal Sorting Machine' that uses a factory metaphor to explain Java's Comparable interface. Diverse objects, such as fruit boxes representing Strings, numbered blocks representing Integers, and people representing Student objects, are shown on a conveyor belt. Despite their differences, each object carries an identical electrical plug labeled compareTo(). These objects are fed into a large central machine labeled Collections.sort(), which accepts the universal plugs to produce sorted output lists. The illustration demonstrates how implementing the single compareTo() method allows different object types to be sorted by the same generic algorithm, contrasting this efficiency with a disorganized scene of a programmer writing repetitive code without the interface."/>

</Slide>

<Slide>

## The Comparable Interface

<div style={{display: 'flex', gap: '2em', alignItems: 'flex-start', marginTop: '1em', fontSize: '0.8em'}}>

<div style={{flex: 1}}>

```mermaid
classDiagram
    class Comparable~T~ {
        <<interface>>
        +compareTo(T o)* int
    }
    class Student {
        -String name
        -int nuid
        +compareTo(Student o) int
    }
    Comparable <|.. Student
    style Comparable fill:#2d4a5a,stroke:#4ac,stroke-width:2px,stroke-dasharray: 5 5
```

</div>

<div style={{flex: 1}}>

```java
public interface Comparable<T> {
    /**
     * Compares this object with the
     * specified object for order.
     *
     * @return negative if this < o,
     *         zero if this == o,
     *         positive if this > o
     */
    int compareTo(T o);
}
```

</div>

</div>

</Slide>

<Slide>

## compareTo Defines How Objects Sort Naturally

<p style={{fontSize: '0.9em'}}>
  For classes with a natural order, implement <code>Comparable&lt;T&gt;</code>:
</p>

```java
/**
 * An NU student. Students are ordered first by name, then by nuid.
*/
public class Student implements Comparable<Student> {
    private String name;
    private int nuid;

    @Override
    public int compareTo(Student other) {
      int nameCompare = this.name.compareTo(other.name);
      if (nameCompare != 0) {
        // one name comes before another
        return nameCompare;
      }
      // names were the same, so sort by nuid
      return Integer.compare(this.nuid, other.nuid);
    }
}
```

<p style={{fontSize: '0.8em', marginTop: '0.5em'}}>
  Returns: negative if <code>this &lt; other</code>, zero if equal, positive if <code>this &gt; other</code>
</p>

<aside className="notes">
**When to implement Comparable:**
- When there's an obvious natural ordering
- Strings: alphabetical
- Dates: chronological
- Numbers: numerical

**The contract:**
- Reversible: sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
- Transitive: if x > y and y > z, then x > z
- Consistent with equals (recommended): x.compareTo(y) == 0 implies x.equals(y)

**Benefits:**
- Works with Arrays.sort(), Collections.sort()
- Works with TreeSet, TreeMap
- One interface, universal sorting

‚Üí **Transition:** A few more implementation tips for compareTo...
</aside>

</Slide>


{/* ============================================ */}
{/* SUMMARY */}
{/* ============================================ */}

<Slide>

## Summary: Specifications as Contracts

<ol style={{fontSize: '0.8em'}}>
  <li><strong>Specifications enable modularity</strong> ‚Äî understand methods without reading implementations (Miller's Law, chunking)</li>
  <li><strong>Good specs balance three criteria:</strong></li>
    <ul>
      <li>Restrictiveness ‚Äî rule out bad implementations</li>
      <li>Generality ‚Äî permit good implementations</li>
      <li>Clarity ‚Äî easy to understand correctly</li>
    </ul>
  <li><strong>Same principles scale</strong> ‚Äî from <code>sum()</code> to enterprise APIs to AI prompts</li>
  <li><strong>Type annotations</strong> make specs machine-checkable (@NullMarked, @Nullable)</li>
  <li><strong>Java's standard contracts</strong> (toString, equals, hashCode, compareTo) must be implemented correctly</li>
</ol>

<aside className="notes">
**Key takeaways:**
- Specs let us reason about large systems (Miller's Law, chunking)
- Balance restrictiveness, generality, clarity
- Same principles at every scale‚Äîmethod, API, AI prompt
- Use type annotations when possible (compiler > comments)
- Learn the Object method contracts by heart

**Critical rules:**
- Override equals ‚Üí MUST override hashCode
- Use same fields in both
- equals(null) returns false, compareTo(null) throws

**The AI connection (preview):**
- When you prompt an AI to implement something, you're writing a spec
- Vague prompts ‚Üí unpredictable implementations
- The skills from today apply directly to AI-assisted development (Lecture 13)

**Connections to upcoming work:**
- A1: Write good Javadoc for your methods
- A1: Override equals/hashCode for domain classes
- Lab 3: Evaluate specification quality
- Lecture 13: AI-assisted development (specs for AI)
- Future lectures: Requirements gathering (where specs come from)

‚Üí **Transition:** Let's look at next steps.
</aside>

</Slide>

<Slide>

## Next Steps

<ul style={{fontSize: '0.95em'}}>
  <li>Assignment 1 due Thursday, January 15 at 11:59 PM</li>
  <li>Complete flashcard set 4 (Specifications & Contracts)</li>
</ul>

<p style={{marginTop: '1.5em', fontSize: '0.9em'}}><strong>Optional readings:</strong></p>

<ul style={{fontSize: '0.85em'}}>
  <li><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch3.xhtml">Effective Java, Items 10-14</a> (equals, hashCode, toString, Comparable)</li>
  <li><a href="https://learning.oreilly.com/library/view/program-development-in/9780768685299/ch9.html">Liskov & Guttag, Chapter 9.2</a> (Specification theory)</li>
  <li><a href="https://jspecify.dev/docs/start-here/">JSpecify Documentation</a> (Nullness annotations standard)</li>
</ul>

<p style={{marginTop: '1.5em', fontSize: '0.9em'}}><strong>Next time:</strong> Functional Programming and Readability</p>

<aside className="notes">
Assignment 1 is due Thursday‚Äîmake sure your methods have good Javadoc and that you override equals/hashCode correctly for your domain classes. The flashcards will help reinforce today's concepts.

**Optional readings:**
- Effective Java Items 10-14 go deeper on the Object method contracts‚Äîhighly recommended if you want to understand the edge cases
- Liskov & Guttag provides the theoretical foundation for specification design
- JSpecify docs if you want to understand the nullness annotation ecosystem

**Next lecture preview:**
- We'll learn lambdas, records, and method references
- Java was decades late to functional programming‚ÄîHaskell had lambdas in 1990, Java got them in 2014
- But better late than never! These tools let us write code where intent is visible, not buried in boilerplate

Any questions before we wrap up?
</aside>

</Slide>

</RevealJS>

